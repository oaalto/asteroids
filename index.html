<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroids</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        #game-canvas {
            display: block;
            border: 2px solid #333;
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
    <div id="elm-root"></div>
    <script src="elm.js"></script>
    <script>
    (function() {
        const app = Elm.Main.init({ node: document.getElementById('elm-root') });

        const CANVAS_W = 800;
        const CANVAS_H = 600;

        const asteroidSizeRadius = { large: 40, medium: 20, small: 10 };
        const asteroidFill = { large: '#555555', medium: '#6b5b3f', small: '#7a5f44' };
        const asteroidStroke = { large: '#999999', medium: '#bb9966', small: '#cc9977' };

        let stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * CANVAS_W,
                y: Math.random() * CANVAS_H,
                brightness: Math.random() * 0.6 + 0.2,
                size: Math.random() * 1.5 + 0.5
            });
        }

        function getCanvas() {
            return document.getElementById('game-canvas');
        }

        function drawStars(ctx) {
            for (const star of stars) {
                ctx.fillStyle = `rgba(255,255,255,${star.brightness})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawShip(ctx, ship, frameCount) {
            if (ship.invincible > 0 && Math.floor(frameCount / 4) % 2 === 0) {
                return; // blink during invincibility
            }

            const angle = ship.angle * Math.PI / 180;
            const r = 15;
            const cx = ship.pos.x;
            const cy = ship.pos.y;

            // Ship body (triangle)
            const nose = { x: cx + Math.cos(angle) * r * 1.3, y: cy + Math.sin(angle) * r * 1.3 };
            const left = { x: cx + Math.cos(angle + 2.4) * r, y: cy + Math.sin(angle + 2.4) * r };
            const right = { x: cx + Math.cos(angle - 2.4) * r, y: cy + Math.sin(angle - 2.4) * r };
            const rear = { x: cx - Math.cos(angle) * r * 0.3, y: cy - Math.sin(angle) * r * 0.3 };

            // Ship fill gradient-like effect
            ctx.beginPath();
            ctx.moveTo(nose.x, nose.y);
            ctx.lineTo(left.x, left.y);
            ctx.lineTo(rear.x, rear.y);
            ctx.lineTo(right.x, right.y);
            ctx.closePath();
            ctx.fillStyle = '#004466';
            ctx.fill();
            ctx.strokeStyle = '#00ccff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Cockpit highlight
            const midX = cx + Math.cos(angle) * r * 0.3;
            const midY = cy + Math.sin(angle) * r * 0.3;
            ctx.beginPath();
            ctx.arc(midX, midY, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#00ffff';
            ctx.fill();

            // Thrust flame
            if (ship.thrusting) {
                const flameLen = 8 + Math.random() * 8;
                const flameBase = 5;
                const backAngle = angle + Math.PI;
                const flameCenter = { x: cx + Math.cos(backAngle) * r * 0.6, y: cy + Math.sin(backAngle) * r * 0.6 };
                const flameTip = { x: flameCenter.x + Math.cos(backAngle) * flameLen, y: flameCenter.y + Math.sin(backAngle) * flameLen };
                const flameL = { x: flameCenter.x + Math.cos(backAngle + 1.3) * flameBase, y: flameCenter.y + Math.sin(backAngle + 1.3) * flameBase };
                const flameR = { x: flameCenter.x + Math.cos(backAngle - 1.3) * flameBase, y: flameCenter.y + Math.sin(backAngle - 1.3) * flameBase };

                ctx.beginPath();
                ctx.moveTo(flameL.x, flameL.y);
                ctx.lineTo(flameTip.x, flameTip.y);
                ctx.lineTo(flameR.x, flameR.y);
                ctx.closePath();
                ctx.fillStyle = Math.random() > 0.5 ? '#ff6600' : '#ffcc00';
                ctx.fill();
            }
        }

        function drawBullet(ctx, bullet) {
            const alpha = Math.min(1, bullet.life / 15);
            ctx.beginPath();
            ctx.arc(bullet.pos.x, bullet.pos.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 100, ${alpha})`;
            ctx.fill();

            // Glow effect
            ctx.beginPath();
            ctx.arc(bullet.pos.x, bullet.pos.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 200, 50, ${alpha * 0.3})`;
            ctx.fill();
        }

        function drawAsteroid(ctx, ast) {
            const radius = asteroidSizeRadius[ast.size] || 40;
            const angle = ast.angle * Math.PI / 180;

            ctx.save();
            ctx.translate(ast.pos.x, ast.pos.y);
            ctx.rotate(angle);

            ctx.beginPath();
            const verts = ast.vertices;
            if (verts.length > 0) {
                ctx.moveTo(verts[0].x * radius, verts[0].y * radius);
                for (let i = 1; i < verts.length; i++) {
                    ctx.lineTo(verts[i].x * radius, verts[i].y * radius);
                }
            }
            ctx.closePath();

            ctx.fillStyle = asteroidFill[ast.size] || '#555';
            ctx.fill();
            ctx.strokeStyle = asteroidStroke[ast.size] || '#999';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }

        function drawParticle(ctx, p) {
            const alpha = p.life / p.maxLife;
            const size = 2 + alpha * 2;
            ctx.beginPath();
            ctx.arc(p.pos.x, p.pos.y, size, 0, Math.PI * 2);
            ctx.fillStyle = hexToRgba(p.color, alpha);
            ctx.fill();
        }

        function hexToRgba(hex, alpha) {
            hex = hex.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            return `rgba(${r},${g},${b},${alpha})`;
        }

        function drawHUD(ctx, score, lives, level) {
            // Score
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 24px "Courier New", monospace';
            ctx.textAlign = 'left';
            ctx.fillText(score.toString().padStart(6, '0'), 20, 35);

            // Level
            ctx.font = '16px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#888888';
            ctx.fillText('LEVEL ' + level, CANVAS_W / 2, 30);

            // Lives (small ship icons)
            for (let i = 0; i < lives; i++) {
                const lx = CANVAS_W - 30 - i * 25;
                const ly = 30;
                ctx.beginPath();
                ctx.moveTo(lx, ly - 10);
                ctx.lineTo(lx - 7, ly + 7);
                ctx.lineTo(lx, ly + 3);
                ctx.lineTo(lx + 7, ly + 7);
                ctx.closePath();
                ctx.fillStyle = '#004466';
                ctx.fill();
                ctx.strokeStyle = '#00ccff';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }

        function drawStartScreen(ctx, frameCount) {
            // Title
            ctx.fillStyle = '#00ccff';
            ctx.font = 'bold 64px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('ASTEROIDS', CANVAS_W / 2, CANVAS_H / 2 - 80);

            // Subtitle
            ctx.fillStyle = '#666666';
            ctx.font = '18px "Courier New", monospace';
            ctx.fillText('An Old-School Classic', CANVAS_W / 2, CANVAS_H / 2 - 40);

            // Controls
            ctx.fillStyle = '#888888';
            ctx.font = '16px "Courier New", monospace';
            ctx.fillText('ARROW KEYS to move  |  SPACE to shoot', CANVAS_W / 2, CANVAS_H / 2 + 20);

            // Blinking start text
            if (Math.floor(frameCount / 30) % 2 === 0) {
                ctx.fillStyle = '#ffcc00';
                ctx.font = 'bold 22px "Courier New", monospace';
                ctx.fillText('PRESS ENTER TO START', CANVAS_W / 2, CANVAS_H / 2 + 70);
            }
        }

        function drawGameOverScreen(ctx, score) {
            // Overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

            // Game Over text
            ctx.fillStyle = '#ff3333';
            ctx.font = 'bold 56px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', CANVAS_W / 2, CANVAS_H / 2 - 50);

            // Score
            ctx.fillStyle = '#ffffff';
            ctx.font = '28px "Courier New", monospace';
            ctx.fillText('FINAL SCORE: ' + score.toString().padStart(6, '0'), CANVAS_W / 2, CANVAS_H / 2 + 10);

            // Restart
            ctx.fillStyle = '#ffcc00';
            ctx.font = '20px "Courier New", monospace';
            ctx.fillText('PRESS ENTER TO PLAY AGAIN', CANVAS_W / 2, CANVAS_H / 2 + 60);
        }

        // Render callback from Elm
        app.ports.render.subscribe(function(scene) {
            const canvas = getCanvas();
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

            // Stars background
            drawStars(ctx);

            // Draw asteroids (always visible in all states)
            for (const ast of scene.asteroids) {
                drawAsteroid(ctx, ast);
            }

            if (scene.state === 'start') {
                drawStartScreen(ctx, scene.frameCount);
            } else if (scene.state === 'playing') {
                // Particles (behind ship)
                for (const p of scene.particles) {
                    drawParticle(ctx, p);
                }

                // Ship
                drawShip(ctx, scene.ship, scene.frameCount);

                // Bullets
                for (const b of scene.bullets) {
                    drawBullet(ctx, b);
                }

                // HUD
                drawHUD(ctx, scene.score, scene.lives, scene.level);
            } else if (scene.state === 'gameover') {
                // Draw remaining particles and ship wreckage
                for (const p of scene.particles) {
                    drawParticle(ctx, p);
                }
                drawHUD(ctx, scene.score, 0, scene.level);
                drawGameOverScreen(ctx, scene.score);
            }

            // Scanline effect (subtle)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
            for (let y = 0; y < CANVAS_H; y += 3) {
                ctx.fillRect(0, y, CANVAS_W, 1);
            }
        });
    })();
    </script>
</body>
</html>
